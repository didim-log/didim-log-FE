import type { TemplateSummary } from '../../../types/api/template.types';

const removeDuplicateCodeSections = (content: string): string => {
    const codeSectionPattern = /(##\s*제출한\s*코드(?:\s*\n|[\s\S]*?)(?:```[\s\S]*?```|(?=\n##|\n---|$)))/gi;
    const matches: RegExpMatchArray[] = [];
    let match: RegExpMatchArray | null;

    while ((match = codeSectionPattern.exec(content)) !== null) {
        matches.push(match);
    }

    if (matches.length <= 1) {
        return content;
    }

    let cleaned = content;
    for (let i = matches.length - 2; i >= 0; i--) {
        const matchText = matches[i][0];
        cleaned = cleaned.replace(matchText, '');
    }

    return cleaned.replace(/\n{3,}/g, '\n\n').trim();
};

export const replaceTemplatePlaceholders = (
    content: string,
    problemId: string,
    tier?: string | null
): string => {
    const problemLink = `https://www.acmicpc.net/problem/${problemId}`;
    const tierText = tier || '티어 정보 없음';

    return content.replace(/\{\{link\}\}/g, problemLink).replace(/\{\{tier\}\}/g, tierText);
};

export const ensureTemplateDefaultSections = (
    templateContent: string,
    problemId: string,
    tier?: string | null
): string => {
    let cleanedContent = removeDuplicateCodeSections(templateContent);
    const sectionsToAppend: string[] = [];

    const hasCodeSectionHeader = /##\s*제출한\s*코드/i.test(cleanedContent);
    const hasCompleteCodeSection = /##\s*제출한\s*코드[\s\S]*?```[\s\S]*?```/i.test(cleanedContent);

    if (!hasCodeSectionHeader) {
        sectionsToAppend.push('## 제출한 코드');
        sectionsToAppend.push('```kotlin\n여기에 코드를 작성하세요.\n```');
    } else if (!hasCompleteCodeSection) {
        cleanedContent = cleanedContent.replace(
            /(##\s*제출한\s*코드\s*)/i,
            '$1\n\n```kotlin\n여기에 코드를 작성하세요.\n```\n'
        );
    }

    const hasProblemLink = /\[문제 링크\]\(/i.test(cleanedContent);
    const hasGeneratedBy = /Generated by DidimLog/i.test(cleanedContent);

    if (!hasProblemLink || !hasGeneratedBy) {
        sectionsToAppend.push('---');
        if (!hasProblemLink) {
            sectionsToAppend.push('[문제 링크]({{link}}) | 티어: {{tier}}');
        }
        if (!hasGeneratedBy) {
            sectionsToAppend.push('Generated by DidimLog');
        }
    }

    const contentWithDefaults =
        sectionsToAppend.length > 0
            ? `${cleanedContent.trim()}\n\n${sectionsToAppend.join('\n\n')}`
            : cleanedContent.trim();

    return replaceTemplatePlaceholders(contentWithDefaults, problemId, tier);
};

export const selectTemplateForRetrospective = (
    templates: TemplateSummary[],
    category: 'SUCCESS' | 'FAIL'
): TemplateSummary | null => {
    const categoryTemplate = templates.find((t) =>
        category === 'SUCCESS' ? t.isDefaultSuccess : t.isDefaultFail
    );
    if (categoryTemplate) {
        return categoryTemplate;
    }

    const systemFallback = templates.find((t) => t.type === 'SYSTEM');
    if (systemFallback) {
        return systemFallback;
    }

    return templates[0] || null;
};
